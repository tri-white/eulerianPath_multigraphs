<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Graph Adjacency Matrix Generator</title>
<style>
    body {
        font-family: Arial, sans-serif;
    }
    table {
        border-collapse: collapse;
        width: 100%;
    }
    th, td {
        padding: 8px;
        text-align: center; /* Align text to center */
        border: 1px solid #dddddd;
    }
    th {
        background-color: #f2f2f2;
    }
</style>
</head>
<body>
<h2>Graph Adjacency Matrix Generator</h2>
<div>
    <label for="numVertices">Enter the number of vertices:</label><br>
    <input type="number" id="numVertices" min="1"><br>
    <button onclick="generateTable()">Generate Table</button>
</div>
<div id="matrixOutput">
    <h3>Adjacency Matrix</h3>
    <div id="tableContainer"></div>
</div>

<button onclick="findEulerLoop()">Find Euler Loop</button>
<div id="inOutTableOutput"></div>
<div id="startEndNodes"></div>
<div id="eulerianOutput">
    <h3>Eulerian Path/Cycle</h3>
    <p id="eulerianPath"></p>
</div>

<script>
    function generateTable() {
        let numVertices = parseInt(document.getElementById('numVertices').value);
        let matrixHTML = '<table id="matrix">';
        
        // Generate table rows and columns with labels
        matrixHTML += '<tr><th></th>';
        for (let i = 1; i <= numVertices; i++) {
            matrixHTML += '<th>' + i + '</th>';
        }
        matrixHTML += '</tr>';
        
        for (let i = 1; i <= numVertices; i++) {
            matrixHTML += '<tr>';
            matrixHTML += '<td>' + i + '</td>';
            for (let j = 1; j <= numVertices; j++) {
                matrixHTML += '<td><input type="text" id="v' + i + '_' + j + '"></td>';
            }
            matrixHTML += '</tr>';
        }
        
        matrixHTML += '</table>';
        
        document.getElementById('tableContainer').innerHTML = matrixHTML;
    }
    let outDegrees = new Array(1).fill(0);
    let edges = {};
function findEulerLoop() {
    let numVertices = parseInt(document.getElementById('numVertices').value);
    edges = {};
    let edgesCount = 0;
    let inDegrees = new Array(numVertices + 1).fill(0);
    outDegrees = new Array(numVertices + 1).fill(0);
    
    // Retrieve distances from the table and calculate degrees
    for (let i = 1; i <= numVertices; i++) {
        edges[i] = [];
        for (let j = 1; j <= numVertices; j++) {
            let distance = document.getElementById('v' + i + '_' + j).value.trim();
            if (distance) {
                let distances = distance.split(',').map(Number);
                distances.forEach(d => {
                    if (d > 0) {
                        edges[i].push(j);
                        edgesCount++;
                        outDegrees[i]++;
                        inDegrees[j]++;
                    }
                });
            }
        }
    }
    
    // Generate table for indegree and outdegree counts
    let inOutTableHTML = '<table>';
    inOutTableHTML += '<tr><th>Node</th><th>In</th><th>Out</th></tr>';
    for (let i = 1; i <= numVertices; i++) {
        inOutTableHTML += '<tr>';
        inOutTableHTML += '<td>' + i + '</td>';
        inOutTableHTML += '<td>' + inDegrees[i] + '</td>';
        inOutTableHTML += '<td>' + outDegrees[i] + '</td>';
        inOutTableHTML += '</tr>';
    }
    inOutTableHTML += '</table>';
    
    document.getElementById('inOutTableOutput').innerHTML = inOutTableHTML;
    
    let startNode = 0;
    let numOddDegrees = 0;
    
    // Check for startNode and endNode based on degrees
    for (let i = 1; i <= numVertices; i++) {
        let diff = outDegrees[i] - inDegrees[i];
        if (diff === 1) {
            startNode = i;
            numOddDegrees++;
        } else if (diff === -1) {
            numOddDegrees++;
        } else if (Math.abs(diff) > 1) {
            document.getElementById('eulerianPath').textContent = "Graph doesn't have an Eulerian path or cycle.";
            return;
        }
    }
    if(startNode===0){
        for (let i = 1; i <= numVertices; i++) {
            if(outDegrees[i]>0) startNode = i;
        }
    }
    
    // Check if the conditions are met
    if (numOddDegrees != 2 && numOddDegrees!=0) {
        document.getElementById('eulerianPath').textContent = "Graph doesn't have an Eulerian path or cycle.";
        return;
    }
    
    // If conditions are met, find the Eulerian path
    let eulerianPath = findEulerianPath(startNode, numVertices, outDegrees, edgesCount);
    
    if (eulerianPath) {
        eulerianPath = eulerianPath.reverse();
        document.getElementById('eulerianPath').textContent = "Eulerian Path/Cycle: " + eulerianPath.join('->');
    } else {
        document.getElementById('eulerianPath').textContent = "Couldn't build eulerian path/loop";
    }

    // Display startNode and endNode
    document.getElementById('startEndNodes').innerHTML = "Start Node: " + startNode;
}

let path = [];

function findEulerianPath(startVertex, numVertices, outDegrees, edgesCount) {
    path = [];
    dfs(startVertex, outDegrees);

    if (path.length == edgesCount+1) return path;
    return [];
}

function dfs(at, outDegrees) {
    // while current node still has outgoing edges
    while(outDegrees[at] != 0 ){

        // get next edge from currentNode, decrease outdegree of current node by 1
        outDegrees[at] = outDegrees[at]-1;

        //set next edge(vertex) that current node is connected to
        let next_edge = edges[at][outDegrees[at]];

        dfs(next_edge, outDegrees);
    }

    // add current node to the solution
    path.push(at);
}

</script>
</body>
</html>
