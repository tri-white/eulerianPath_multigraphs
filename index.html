<!--
    1.	Задано матрицю суміжності
     орієнтованого мультиграфа. 
     Визначити, чи має він ейлерів цикл,
      а якщо ні , то ейлерів шлях. 
      Побудувати ейлерів цикл або шлях,
       якщо вони існують. Побудувати.

       1 1 1
2 1 2
1 3 2
3 2 3
3 2 6
1 3 2
1 3 7
-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Graph Adjacency Matrix Generator</title>
<style>
    body {
        font-family: Arial, sans-serif;
    }
    table {
        border-collapse: collapse;
        width: 100%;
    }
    th, td {
        padding: 8px;
        text-align: center; /* Align text to center */
        border: 1px solid #dddddd;
    }
    th {
        background-color: #f2f2f2;
    }
</style>
</head>
<body>
<h2>Graph Adjacency Matrix Generator</h2>
<div>
    <label for="input">Enter edges and distances (format: vertex1 vertex2 distance):</label><br>
    <textarea id="input" rows="5" cols="50"></textarea><br>
    <button onclick="generateMatrix()">Generate Matrix</button>
</div>
<div id="matrixOutput">
    <h3>Adjacency Matrix</h3>
    <table id="matrix"></table>
</div>

<script>
    function generateMatrix() {
        let inputText = document.getElementById('input').value.trim();
        let lines = inputText.split('\n');
        let maxVertex = 0;
        
        // Find the maximum vertex number
        lines.forEach(line => {
            let [v1, v2] = line.split(' ').map(Number);
            maxVertex = Math.max(maxVertex, v1, v2);
        });
    
        // Initialize adjacency matrix with zeros
        let matrix = [];
        for (let i = 0; i <= maxVertex; i++) {
            matrix.push(new Array(maxVertex+1).fill(''));
        }
    
        // Fill adjacency matrix for directed graph
        lines.forEach(line => {
            let [v1, v2, distance] = line.split(' ').map(Number);
            if (matrix[v1][v2] !== '') {
                // If there's already a distance, append the new one
                matrix[v1][v2] += ',' + distance;
            } else {
                matrix[v1][v2] = distance.toString();
            }
        });
    
        // Clear previous matrix
        let matrixTable = document.getElementById('matrix');
        while (matrixTable.firstChild) {
            matrixTable.removeChild(matrixTable.firstChild);
        }
    
        // Add headers for columns
        let headerRow = matrixTable.insertRow();
        for (let j = 0; j <= maxVertex; j++) {
            let headerCell = headerRow.insertCell();
            if (j !== 0) {
                headerCell.textContent = 'V' + j;
            }
        }
    
        // Fill matrix and add row headers
        for (let i = 1; i <= maxVertex; i++) {
            let row = matrixTable.insertRow();
            let rowHeader = row.insertCell();
            rowHeader.textContent = 'V' + i;
            for (let j = 1; j <= maxVertex; j++) {
                let cell = row.insertCell();
                cell.textContent = matrix[i][j];
            }
        }
    }
    </script>
    
</body>
</html>
