<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Graph Adjacency Matrix Generator</title>
<style>
    body {
        font-family: Arial, sans-serif;
    }
    table {
        border-collapse: collapse;
        width: 100%;
    }
    th, td {
        padding: 8px;
        text-align: center; /* Align text to center */
        border: 1px solid #dddddd;
    }
    th {
        background-color: #f2f2f2;
    }
</style>
</head>
<body>
<h2>Graph Adjacency Matrix Generator</h2>
<div>
    <label for="numVertices">Enter the number of vertices:</label><br>
    <input type="number" id="numVertices" min="1"><br>
    <button onclick="generateTable()">Generate Table</button>
</div>
<div id="matrixOutput">
    <h3>Adjacency Matrix</h3>
    <div id="tableContainer"></div>
</div>
<div id="inOutTableOutput"></div>
<div id="startEndNodes"></div>
<button onclick="findEulerLoop()">Find Euler Loop</button>
<div id="eulerianOutput">
    <h3>Eulerian Path/Cycle</h3>
    <p id="eulerianPath"></p>
</div>

<script>
    function generateTable() {
        let numVertices = parseInt(document.getElementById('numVertices').value);
        let matrixHTML = '<table id="matrix">';
        
        // Generate table rows and columns with labels
        matrixHTML += '<tr><th></th>';
        for (let i = 1; i <= numVertices; i++) {
            matrixHTML += '<th>' + i + '</th>';
        }
        matrixHTML += '</tr>';
        
        for (let i = 1; i <= numVertices; i++) {
            matrixHTML += '<tr>';
            matrixHTML += '<td>' + i + '</td>';
            for (let j = 1; j <= numVertices; j++) {
                matrixHTML += '<td><input type="text" id="v' + i + '_' + j + '"></td>';
            }
            matrixHTML += '</tr>';
        }
        
        matrixHTML += '</table>';
        
        document.getElementById('tableContainer').innerHTML = matrixHTML;
    }
    
    function findEulerLoop() {
        let numVertices = parseInt(document.getElementById('numVertices').value);
        let edges = {};
        let inDegrees = new Array(numVertices + 1).fill(0);
        let outDegrees = new Array(numVertices + 1).fill(0);
        
        // Retrieve distances from the table and calculate degrees
        for (let i = 1; i <= numVertices; i++) {
            edges[i] = [];
            for (let j = 1; j <= numVertices; j++) {
                let distance = document.getElementById('v' + i + '_' + j).value.trim();
                if (distance) {
                    let distances = distance.split(',').map(Number);
                    distances.forEach(d => {
                        if (d > 0) {
                            edges[i].push(j);
                            outDegrees[i]++;
                            inDegrees[j]++;
                        }
                    });
                }
            }
        }
        
        // Generate table for indegree and outdegree counts
        let inOutTableHTML = '<table>';
        inOutTableHTML += '<tr><th>Node</th><th>In</th><th>Out</th></tr>';
        for (let i = 1; i <= numVertices; i++) {
            inOutTableHTML += '<tr>';
            inOutTableHTML += '<td>' + i + '</td>';
            inOutTableHTML += '<td>' + inDegrees[i] + '</td>';
            inOutTableHTML += '<td>' + outDegrees[i] + '</td>';
            inOutTableHTML += '</tr>';
        }
        inOutTableHTML += '</table>';
        
        document.getElementById('inOutTableOutput').innerHTML = inOutTableHTML;
        
        let startNode = 0;
        let endNode = 0;
        let numOddDegreesOut = 0;
        let numOddDegreesIn = 0;
        
        // Check for startNode and endNode based on degrees
        for (let i = 1; i <= numVertices; i++) {
            let diff = outDegrees[i] - inDegrees[i];
            if (diff === 1) {
                startNode = i;
                numOddDegreesOut++;
            } else if (diff === -1) {
                endNode = i;
                numOddDegreesIn++;
            } else if (Math.abs(diff) > 1) {
                document.getElementById('eulerianPath').textContent = "Graph doesn't have an Eulerian path or cycle.";
                return;
            }
        }
        
        // Check if the conditions are met
        if (numOddDegreesIn >1  ||  numOddDegreesOut > 1 || (startNode !== 0 && endNode !== 0 && startNode === endNode) || (startNode === 0 && endNode === 0 && numOddDegrees !== 0)) {
            document.getElementById('eulerianPath').textContent = "Graph doesn't have an Eulerian path or cycle.";
            return;
        }
        
        // If conditions are met, find the Eulerian path
        let eulerianPath = findEulerianPath(startNode, endNode, edges, numVertices);
        
        if (eulerianPath) {
            document.getElementById('eulerianPath').textContent = "Eulerian Path/Cycle: " + eulerianPath.join('->');
        } else {
            document.getElementById('eulerianPath').textContent = "Graph doesn't have an Eulerian path or cycle.";
        }

        // Display startNode and endNode
        document.getElementById('startEndNodes').innerHTML = "Start Node: " + startNode + ", End Node: " + endNode;
    }
    
    function findEulerianPath(startVertex, endVertex, edges, numVertices) {
        let path = [];
        let stack = [startVertex];
        
        while (stack.length > 0) {
            let currentVertex = stack[stack.length - 1];
            
            if (edges[currentVertex] && edges[currentVertex].length > 0) {
                let nextVertex = edges[currentVertex].shift();
                stack.push(nextVertex);
            } else {
                // Add the current vertex to the path only if it hasn't been visited before
                if (!path.includes(currentVertex)) {
                    path.unshift(stack.pop());
                    if (currentVertex === endVertex) break; // Stop when reaching the endNode
                } else {
                    stack.pop();
                }
            }
        }
        
        // Check if the path forms a cycle and includes all edges
        let visited = {};
        path.forEach(vertex => {
            visited[vertex] = true;
        });
        
        for (let vertex in edges) {
            if (!visited[vertex] || edges[vertex].length > 0) {
                return null;
            }
        }
        
        return path.length > 0 && path.length <= numVertices ? path : null;
    }
</script>
</body>
</html>
