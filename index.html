<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Graph Adjacency Matrix Generator</title>
<style>
    body {
        font-family: Arial, sans-serif;
    }
    table {
        border-collapse: collapse;
        width: 100%;
    }
    th, td {
        padding: 8px;
        text-align: center; /* Align text to center */
        border: 1px solid #dddddd;
    }
    th {
        background-color: #f2f2f2;
    }
</style>
</head>
<body>
<h2>Graph Adjacency Matrix Generator</h2>
<div>
    <label for="input">Enter edges and distances (format: vertex1 vertex2 distance):</label><br>
    <textarea id="input" rows="5" cols="50"></textarea><br>
    <button onclick="generateMatrix()">Generate Matrix</button>
</div>
<div id="matrixOutput">
    <h3>Adjacency Matrix</h3>
    <table id="matrix"></table>
</div>
<div id="eulerianOutput">
    <h3>Eulerian Path/Cycle</h3>
    <p id="eulerianPath"></p>
</div>

<script>
    function generateMatrix() {
        let inputText = document.getElementById('input').value.trim();
        let lines = inputText.split('\n');
        let maxVertex = 0;
        
        // Find the maximum vertex number
        lines.forEach(line => {
            let [v1, v2] = line.split(' ').map(Number);
            maxVertex = Math.max(maxVertex, v1, v2);
        });
    
        // Initialize adjacency matrix with zeros
        let matrix = [];
        for (let i = 0; i <= maxVertex; i++) {
            matrix.push(new Array(maxVertex+1).fill(''));
        }
    
        // Fill adjacency matrix for directed graph
        lines.forEach(line => {
            let [v1, v2, distance] = line.split(' ').map(Number);
            if (matrix[v1][v2] !== '') {
                // If there's already a distance, append the new one
                matrix[v1][v2] += ',' + distance;
            } else {
                matrix[v1][v2] = distance.toString();
            }
        });
    
        // Clear previous matrix
        let matrixTable = document.getElementById('matrix');
        while (matrixTable.firstChild) {
            matrixTable.removeChild(matrixTable.firstChild);
        }
    
        // Add headers for columns
        let headerRow = matrixTable.insertRow();
        for (let j = 0; j <= maxVertex; j++) {
            let headerCell = headerRow.insertCell();
            if (j !== 0) {
                headerCell.textContent = 'V' + j;
            }
        }
    
        // Fill matrix and add row headers
        for (let i = 1; i <= maxVertex; i++) {
            let row = matrixTable.insertRow();
            let rowHeader = row.insertCell();
            rowHeader.textContent = 'V' + i;
            for (let j = 1; j <= maxVertex; j++) {
                let cell = row.insertCell();
                cell.textContent = matrix[i][j];
            }
        }
        
        // Check for Eulerian path or cycle
        let inDegrees = new Array(maxVertex + 1).fill(0);
        let outDegrees = new Array(maxVertex + 1).fill(0);
        let edges = {};
        
        lines.forEach(line => {
            let [v1, v2, distance] = line.split(' ').map(Number);
            outDegrees[v1]++;
            inDegrees[v2]++;
            if (!edges[v1]) edges[v1] = [];
            edges[v1].push(v2);
        });
        
        let oddVertices = [];
        for (let i = 1; i <= maxVertex; i++) {
            if ((inDegrees[i] - outDegrees[i]) !== 0) {
                if (Math.abs(inDegrees[i] - outDegrees[i]) === 1) {
                    oddVertices.push(i);
                } else {
                    document.getElementById('eulerianPath').textContent = "Graph doesn't have an Eulerian path or cycle.";
                    return;
                }
            }
        }
        
        let startVertex = 1;
        if (oddVertices.length === 0) {
            // If no odd vertices, start from any vertex
            startVertex = 1;
        } else if (oddVertices.length === 2) {
            // If two odd vertices, start from one of them
            startVertex = oddVertices[0];
        } else {
            document.getElementById('eulerianPath').textContent = "Graph doesn't have an Eulerian path or cycle.";
            return;
        }
        
        let eulerianPath = findEulerianPath(startVertex, edges);
        
        if (eulerianPath) {
            document.getElementById('eulerianPath').textContent = "Eulerian Path/Cycle: " + eulerianPath.join('->');
        } else {
            document.getElementById('eulerianPath').textContent = "Graph doesn't have an Eulerian path or cycle.";
        }
    }
    
    function findEulerianPath(vertex, edges) {
        let path = [];
        let stack = [vertex];
        
        while (stack.length > 0) {
            let currentVertex = stack[stack.length - 1];
            
            if (edges[currentVertex] && edges[currentVertex].length > 0) {
                stack.push(edges[currentVertex].shift());
            } else {
                path.unshift(stack.pop());
            }
        }
        
        return path.length > 0 ? path : null;
    }
</script>
</body>
</html>
